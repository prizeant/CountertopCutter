<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Countertop Cutting Optimizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        /* Additional styles for icons since we can't use lucide-react */
        .icon {
            width: 1rem;
            height: 1rem;
            display: inline-block;
            vertical-align: middle;
        }
        .icon-trash {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16' /%3E%3C/svg%3E");
        }
        .icon-plus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z' /%3E%3C/svg%3E");
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState } = React;

        // Constants for slab dimensions
        const DEFAULT_SLAB_WIDTH = 133;
        const DEFAULT_SLAB_HEIGHT = 78;

        const CountertopOptimizer = () => {
            // Define algorithm types
            const GUILLOTINE = "guillotine";
            const SIMULATED_ANNEALING = "simulated_annealing";

            const [countertops, setCountertops] = useState([
                { id: 1, width: 137, height: 26, label: 'Long Countertop' },
                { id: 2, width: 78, height: 44, label: 'Island' },
                { id: 3, width: 50, height: 26, label: 'Stove Left' },
                { id: 4, width: 24, height: 26, label: 'Stove Right' },
                { id: 5, width: 72, height: 26, label: 'Bar' },
                { id: 6, width: 110, height: 26, label: 'Bathroom' },
                { id: 7, width: 110, height: 4, label: 'Bathroom Back' },
                { id: 8, width: 42, height: 15, label: 'Bathroom Bench' },
                { id: 9, width: 162, height: 18, label: 'Long Backsplash' },
                { id: 10, width: 50, height: 18, label: 'Stove Backsplash Left' },
                { id: 11, width: 30, height: 30, label: 'Stove Backsplash Center' },
                { id: 12, width: 24, height: 18, label: 'Stove Backsplash Right' }
            ]);
            const [nextId, setNextId] = useState(13);
            const [slabWidth, setSlabWidth] = useState(DEFAULT_SLAB_WIDTH);
            const [slabHeight, setSlabHeight] = useState(DEFAULT_SLAB_HEIGHT);
            const [result, setResult] = useState(null);
            const [showOptimalCuts, setShowOptimalCuts] = useState(false);
            const [allowSplitting, setAllowSplitting] = useState(true);
            const [minSplitLength, setMinSplitLength] = useState(24);
            const [algorithm, setAlgorithm] = useState(GUILLOTINE);
            const [isProcessing, setIsProcessing] = useState(false);

            const addCountertop = () => {
                setCountertops([
                    ...countertops, 
                    { id: nextId, width: 48, height: 26, label: `Countertop ${nextId}` }
                ]);
                setNextId(nextId + 1);
            };

            const updateCountertop = (id, field, value) => {
                setCountertops(
                    countertops.map(c => 
                        c.id === id ? { ...c, [field]: field === 'width' || field === 'height' ? parseInt(value) || 0 : value } : c
                    )
                );
            };

            const removeCountertop = (id) => {
                setCountertops(countertops.filter(c => c.id !== id));
            };

            // Pre-process pieces (split oversized pieces)
            const preprocessPieces = () => {
                let pieces = [];
                let splitPiecesInfo = [];

                countertops.forEach(c => {
                    // Check if this piece needs to be split
                    if (allowSplitting && ((c.width > slabWidth && c.height <= slabHeight) || 
                                       (c.height > slabHeight && c.width <= slabWidth))) {
                        // This piece is too long in one dimension but can be split

                        // Determine if we should split horizontally or vertically
                        const splitHorizontally = c.width > slabWidth && c.height <= slabHeight;

                        if (splitHorizontally) {
                            // Split horizontally (width-wise)
                            let remainingWidth = c.width;
                            let piecesMade = 0;
                            let piecesCreated = [];

                            while (remainingWidth > 0) {
                                // Determine width of this segment
                                const segmentWidth = Math.min(remainingWidth, slabWidth);

                                // Only create pieces that meet minimum size requirement
                                if (segmentWidth >= minSplitLength) {
                                    const newPiece = {
                                        id: `${c.id}_${piecesMade + 1}`, // e.g. "4_1", "4_2"
                                        originalId: c.id,
                                        width: segmentWidth,
                                        height: c.height,
                                        area: segmentWidth * c.height,
                                        label: `${c.label} (Part ${piecesMade + 1})`,
                                        isSplit: true,
                                        rotated: false
                                    };

                                    pieces.push(newPiece);
                                    piecesCreated.push(newPiece);
                                    piecesMade++;
                                }

                                remainingWidth -= segmentWidth;
                            }

                            // Store information about the split
                            if (piecesMade > 0) {
                                splitPiecesInfo.push({
                                    originalId: c.id,
                                    originalLabel: c.label,
                                    parts: piecesMade,
                                    pieces: piecesCreated
                                });
                            }
                        } else {
                            // Split vertically (height-wise)
                            let remainingHeight = c.height;
                            let piecesMade = 0;
                            let piecesCreated = [];

                            while (remainingHeight > 0) {
                                // Determine height of this segment
                                const segmentHeight = Math.min(remainingHeight, slabHeight);

                                // Only create pieces that meet minimum size requirement
                                if (segmentHeight >= minSplitLength) {
                                    const newPiece = {
                                        id: `${c.id}_${piecesMade + 1}`,
                                        originalId: c.id,
                                        width: c.width,
                                        height: segmentHeight,
                                        area: c.width * segmentHeight,
                                        label: `${c.label} (Part ${piecesMade + 1})`,
                                        isSplit: true,
                                        rotated: false
                                    };

                                    pieces.push(newPiece);
                                    piecesCreated.push(newPiece);
                                    piecesMade++;
                                }

                                remainingHeight -= segmentHeight;
                            }

                            // Store information about the split
                            if (piecesMade > 0) {
                                splitPiecesInfo.push({
                                    originalId: c.id,
                                    originalLabel: c.label,
                                    parts: piecesMade,
                                    pieces: piecesCreated
                                });
                            }
                        }
                    } else {
                        // No splitting needed, use as is
                        pieces.push({
                            id: c.id,
                            width: c.width,
                            height: c.height,
                            area: c.width * c.height,
                            label: c.label,
                            isSplit: false,
                            rotated: false
                        });
                    }
                });

                return { pieces, splitPiecesInfo };
            };

            // ALGORITHM: Guillotine Cutting (Best Fit Decreasing)
            const runOptimization = () => {
                setIsProcessing(true);

                setTimeout(() => {
                    try {
                        // Preprocess pieces
                        const { pieces, splitPiecesInfo } = preprocessPieces();

                        // Check for oversized pieces
                        const oversizedPieces = pieces.filter(p => 
                            (p.width > slabWidth && p.height > slabHeight) && 
                            (p.width > slabHeight && p.height > slabWidth)
                        );

                        if (oversizedPieces.length > 0) {
                            setResult({
                                error: true,
                                errorMessage: `Some pieces are too large to fit on any slab, even after splitting: ${oversizedPieces.map(p => p.label).join(', ')}`,
                                oversizedPieces
                            });
                            setIsProcessing(false);
                            return;
                        }

                        // Consider rotation for each piece
                        pieces.forEach(piece => {
                            const normalFits = piece.width <= slabWidth && piece.height <= slabHeight;
                            const rotatedFits = piece.height <= slabWidth && piece.width <= slabHeight;

                            if (!normalFits && rotatedFits) {
                                piece.rotated = true;
                                [piece.width, piece.height] = [piece.height, piece.width];
                            } else if (normalFits && rotatedFits) {
                                // Choose best orientation
                                const pieceRatio = piece.width / piece.height;
                                const slabRatio = slabWidth / slabHeight;

                                if ((pieceRatio < 1 && slabRatio > 1) || (pieceRatio > 1 && slabRatio < 1)) {
                                    piece.rotated = true;
                                    [piece.width, piece.height] = [piece.height, piece.width];
                                }
                            }
                        });

                        // Sort pieces by area in descending order
                        pieces.sort((a, b) => b.area - a.area);

                        // Initialize slabs array
                        const slabs = [];

                        // For each piece, find a place in existing slabs or create a new slab
                        pieces.forEach(piece => {
                            let placed = false;

                            // Try to place in existing slabs
                            for (let i = 0; i < slabs.length; i++) {
                                const slab = slabs[i];

                                if (slab.spaces.length === 0) {
                                    continue;
                                }

                                // Find best fit space
                                let bestFitIndex = -1;
                                let bestFitWaste = Infinity;

                                for (let j = 0; j < slab.spaces.length; j++) {
                                    const space = slab.spaces[j];

                                    if (piece.width <= space.width && piece.height <= space.height) {
                                        const widthWaste = space.width - piece.width;
                                        const heightWaste = space.height - piece.height;
                                        const totalWaste = widthWaste * piece.height + heightWaste * space.width;

                                        if (totalWaste < bestFitWaste) {
                                            bestFitWaste = totalWaste;
                                            bestFitIndex = j;
                                        }
                                    }
                                }

                                // If we found a space, place the piece there
                                if (bestFitIndex !== -1) {
                                    const space = slab.spaces[bestFitIndex];

                                    // Place piece
                                    slab.pieces.push({
                                        ...piece,
                                        x: space.x,
                                        y: space.y
                                    });

                                    // Split remaining space
                                    const oldSpace = slab.spaces.splice(bestFitIndex, 1)[0];

                                    // Horizontal split (below the piece)
                                    if (oldSpace.height > piece.height) {
                                        slab.spaces.push({
                                            x: oldSpace.x,
                                            y: oldSpace.y + piece.height,
                                            width: oldSpace.width,
                                            height: oldSpace.height - piece.height
                                        });
                                    }

                                    // Vertical split (to the right of the piece)
                                    if (oldSpace.width > piece.width) {
                                        slab.spaces.push({
                                            x: oldSpace.x + piece.width,
                                            y: oldSpace.y,
                                            width: oldSpace.width - piece.width,
                                            height: piece.height
                                        });
                                    }

                                    // Sort spaces by area
                                    slab.spaces.sort((a, b) => (a.width * a.height) - (b.width * b.height));

                                    placed = true;
                                    break;
                                }
                            }

                            // If not placed, create a new slab
                            if (!placed) {
                                const newSlab = {
                                    id: slabs.length + 1,
                                    pieces: [{
                                        ...piece,
                                        x: 0,
                                        y: 0
                                    }],
                                    spaces: []
                                };

                                // Create spaces for remaining area
                                if (slabHeight > piece.height) {
                                    newSlab.spaces.push({
                                        x: 0,
                                        y: piece.height,
                                        width: slabWidth,
                                        height: slabHeight - piece.height
                                    });
                                }

                                if (slabWidth > piece.width) {
                                    newSlab.spaces.push({
                                        x: piece.width,
                                        y: 0,
                                        width: slabWidth - piece.width,
                                        height: piece.height
                                    });
                                }

                                slabs.push(newSlab);
                            }
                        });

                        // Calculate waste for each slab
                        slabs.forEach(slab => {
                            let usedArea = slab.pieces.reduce((sum, piece) => sum + (piece.width * piece.height), 0);
                            slab.totalArea = slabWidth * slabHeight;
                            slab.wasteArea = slab.totalArea - usedArea;
                            slab.wastePercentage = ((slab.wasteArea / slab.totalArea) * 100).toFixed(1);
                        });

                        // Calculate overall statistics
                        const totalPieces = pieces.length;
                        const totalSlabs = slabs.length;
                        const totalAreaNeeded = pieces.reduce((sum, piece) => sum + (piece.width * piece.height), 0);
                        const totalSlabArea = slabs.length * (slabWidth * slabHeight);
                        const totalWaste = totalSlabArea - totalAreaNeeded;
                        const totalWastePercentage = ((totalWaste / totalSlabArea) * 100).toFixed(1);

                        setResult({
                            slabs,
                            totalPieces,
                            totalSlabs,
                            totalAreaNeeded,
                            totalSlabArea,
                            totalWaste,
                            totalWastePercentage,
                            splitPieces: splitPiecesInfo
                        });
                    } catch (error) {
                        console.error("Optimization error:", error);
                        setResult({
                            error: true,
                            errorMessage: `An error occurred during optimization: ${error.message}`
                        });
                    } finally {
                        setIsProcessing(false);
                    }
                }, 50);
            };

            // Color palette for visualization
            const colors = [
                '#4299e1', '#48bb78', '#ed8936', '#ed64a6', '#9f7aea',
                '#667eea', '#68d391', '#f6ad55', '#f687b3', '#b794f4'
            ];

            return React.createElement('div', { className: "flex flex-col p-4 space-y-6" },
                React.createElement('h1', { className: "text-2xl font-bold" }, "Countertop Cutting Optimizer"),
                
                React.createElement('div', { className: "flex flex-col md:flex-row gap-4" },
                    React.createElement('div', { className: "flex-1" },
                        React.createElement('div', { className: "border rounded-lg p-4" },
                            React.createElement('h2', { className: "text-xl font-semibold mb-4" }, "Stone Slab Settings"),
                            React.createElement('div', { className: "grid grid-cols-2 gap-4" },
                                React.createElement('div', null,
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Slab Width (inches)"),
                                    React.createElement('input', {
                                        type: "number",
                                        value: slabWidth,
                                        onChange: (e) => setSlabWidth(parseInt(e.target.value) || DEFAULT_SLAB_WIDTH),
                                        className: "w-full p-2 border rounded"
                                    })
                                ),
                                React.createElement('div', null,
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Slab Height (inches)"),
                                    React.createElement('input', {
                                        type: "number",
                                        value: slabHeight,
                                        onChange: (e) => setSlabHeight(parseInt(e.target.value) || DEFAULT_SLAB_HEIGHT),
                                        className: "w-full p-2 border rounded"
                                    })
                                )
                            ),
                            
                            React.createElement('div', { className: "mt-4 border-t pt-4" },
                                React.createElement('h3', { className: "font-medium mb-2" }, "Splitting Options"),
                                React.createElement('div', { className: "flex items-center mb-2" },
                                    React.createElement('input', {
                                        type: "checkbox",
                                        id: "allowSplitting",
                                        checked: allowSplitting,
                                        onChange: (e) => setAllowSplitting(e.target.checked),
                                        className: "mr-2"
                                    }),
                                    React.createElement('label', { htmlFor: "allowSplitting", className: "text-sm" }, "Allow splitting long countertops into sections")
                                ),
                                
                                allowSplitting && React.createElement('div', null,
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Minimum section length (inches)"),
                                    React.createElement('input', {
                                        type: "number",
                                        value: minSplitLength,
                                        onChange: (e) => setMinSplitLength(parseInt(e.target.value) || 12),
                                        className: "w-full p-2 border rounded",
                                        min: "6",
                                        max: "48"
                                    }),
                                    React.createElement('p', { className: "text-xs text-gray-500 mt-1" }, "Sections smaller than this will be avoided")
                                )
                            ),
                            
                            React.createElement('div', { className: "mt-4 border-t pt-4" },
                                React.createElement('h3', { className: "font-medium mb-2" }, "Optimization Algorithm"),
                                React.createElement('div', { className: "mb-2" },
                                    React.createElement('select', {
                                        value: algorithm,
                                        onChange: (e) => setAlgorithm(e.target.value),
                                        className: "w-full p-2 border rounded"
                                    },
                                        React.createElement('option', { value: GUILLOTINE }, "Guillotine Cutting (Fast)"),
                                        React.createElement('option', { value: SIMULATED_ANNEALING }, "Simulated Annealing (Coming Soon)")
                                    ),
                                    React.createElement('p', { className: "text-xs text-gray-500 mt-1" }, "The Simulated Annealing option is planned for a future update")
                                )
                            )
                        ),
                        
                        React.createElement('div', { className: "border rounded-lg p-4 mt-4" },
                            React.createElement('div', { className: "flex justify-between items-center mb-4" },
                                React.createElement('h2', { className: "text-xl font-semibold" }, "Your Countertops"),
                                React.createElement('button', {
                                    onClick: addCountertop,
                                    className: "flex items-center text-blue-600 hover:text-blue-800"
                                },
                                    React.createElement('span', { className: "icon icon-plus mr-1" }),
                                    " Add Countertop"
                                )
                            ),
                            
                            React.createElement('div', { className: "overflow-x-auto" },
                                React.createElement('table', { className: "min-w-full" },
                                    React.createElement('thead', null,
                                        React.createElement('tr', { className: "border-b" },
                                            React.createElement('th', { className: "text-left p-2" }, "Label"),
                                            React.createElement('th', { className: "text-left p-2" }, "Width (in)"),
                                            React.createElement('th', { className: "text-left p-2" }, "Height (in)"),
                                            React.createElement('th', { className: "text-left p-2" }, "Actions")
                                        )
                                    ),
                                    React.createElement('tbody', null,
                                        countertops.map(c => 
                                            React.createElement('tr', { key: c.id, className: "border-b hover:bg-gray-50" },
                                                React.createElement('td', { className: "p-2" },
                                                    React.createElement('input', {
                                                        type: "text",
                                                        value: c.label,
                                                        onChange: (e) => updateCountertop(c.id, 'label', e.target.value),
                                                        className: "w-full p-1 border rounded"
                                                    })
                                                ),
                                                React.createElement('td', { className: "p-2" },
                                                    React.createElement('input', {
                                                        type: "number",
                                                        value: c.width,
                                                        onChange: (e) => updateCountertop(c.id, 'width', e.target.value),
                                                        className: "w-full p-1 border rounded"
                                                    })
                                                ),
                                                React.createElement('td', { className: "p-2" },
                                                    React.createElement('input', {
                                                        type: "number",
                                                        value: c.height,
                                                        onChange: (e) => updateCountertop(c.id, 'height', e.target.value),
                                                        className: "w-full p-1 border rounded"
                                                    })
                                                ),
                                                React.createElement('td', { className: "p-2" },
                                                    React.createElement('button', {
                                                        onClick: () => removeCountertop(c.id),
                                                        className: "text-red-600 hover:text-red-800"
                                                    },
                                                        React.createElement('span', { className: "icon icon-trash" })
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            ),
                            
                            React.createElement('div', { className: "mt-4" },
                                React.createElement('button', {
                                    onClick: runOptimization,
                                    disabled: isProcessing,
                                    className: `bg-blue-600 text-white px-4 py-2 rounded ${isProcessing ? 'opacity-70' : 'hover:bg-blue-700'}`
                                },
                                    isProcessing ? 'Optimizing...' : 'Optimize Cutting Layout'
                                )
                            )
                        )
                    ),
                    
                    React.createElement('div', { className: "flex-1" },
                        result && result.error ? 
                            React.createElement('div', { className: "border rounded-lg p-4 bg-red-50" },
                                React.createElement('h2', { className: "text-xl font-semibold mb-4 text-red-700" }, "Error in Optimization"),
                                React.createElement('p', { className: "text-red-600 mb-4" }, result.errorMessage),
                                React.createElement('div', { className: "bg-white p-4 rounded border border-red-200" },
                                    React.createElement('h3', { className: "font-medium mb-2" }, "Problematic Pieces:"),
                                    React.createElement('ul', { className: "list-disc pl-5" },
                                        result.oversizedPieces && result.oversizedPieces.map(piece => 
                                            React.createElement('li', { key: piece.id, className: "mb-1" },
                                                `${piece.label}: ${piece.width}" × ${piece.height}" (Slab size: ${slabWidth}" × ${slabHeight}")`
                                            )
                                        )
                                    ),
                                    React.createElement('p', { className: "mt-4 text-sm text-gray-600" },
                                        "Suggestions: Either reduce the size of these pieces, split them into smaller sections, or increase your slab dimensions."
                                    )
                                )
                            ) :
                            result && React.createElement('div', { className: "border rounded-lg p-4" },
                                React.createElement('h2', { className: "text-xl font-semibold mb-4" }, "Optimization Results"),
                                
                                React.createElement('div', { className: "grid grid-cols-2 gap-2 mb-4" },
                                    React.createElement('div', { className: "bg-gray-100 p-2 rounded" },
                                        React.createElement('div', { className: "text-sm text-gray-600" }, "Total Slabs Needed"),
                                        React.createElement('div', { className: "text-xl font-bold" }, result.totalSlabs)
                                    ),
                                    React.createElement('div', { className: "bg-gray-100 p-2 rounded" },
                                        React.createElement('div', { className: "text-sm text-gray-600" }, "Waste Percentage"),
                                        React.createElement('div', { className: "text-xl font-bold" }, `${result.totalWastePercentage}%`)
                                    ),
                                    React.createElement('div', { className: "bg-gray-100 p-2 rounded" },
                                        React.createElement('div', { className: "text-sm text-gray-600" }, "Total Area Needed"),
                                        React.createElement('div', { className: "text-xl font-bold" }, `${result.totalAreaNeeded} sq in`)
                                    ),
                                    React.createElement('div', { className: "bg-gray-100 p-2 rounded" },
                                        React.createElement('div', { className: "text-sm text-gray-600" }, "Total Waste Area"),
                                        React.createElement('div', { className: "text-xl font-bold" }, `${result.totalWaste} sq in`)
                                    )
                                ),
                                
                                React.createElement('div', { className: "mb-4" },
                                    React.createElement('button', {
                                        onClick: () => setShowOptimalCuts(!showOptimalCuts),
                                        className: "text-blue-600 hover:text-blue-800"
                                    },
                                        showOptimalCuts ? 'Hide Cutting Layout' : 'Show Cutting Layout'
                                    )
                                ),
                                
                                showOptimalCuts && React.createElement('div', { className: "space-y-6" },
                                    result.slabs.map((slab, slabIndex) => 
                                        React.createElement('div', { key: slab.id, className: "border rounded p-4" },
                                            React.createElement('h3', { className: "font-semibold mb-2" }, `Slab ${slab.id} (Waste: ${slab.wastePercentage}%)`),
                                            React.createElement('div', { 
                                                className: "relative",
                                                style: { width
